---@diagnostic disable: unused-function, unused-local
loadstring(game:HttpGet('https://raw.githubusercontent.com/drillygzzly/Roblox-UI-Libs/main/Yun%20V2%20Lib/Yun%20V2%20Lib%20Source.lua'))()

local notif = loadstring(game:HttpGet("https://raw.githubusercontent.com/insanedude59/notiflib/main/main"))()


notif:Notification("EXZILE Beta","Loading","GothamSemibold","Gotham",5) -- title: <string> description: <string> title font: <string> description font: <string> notification show time: <number>

local Library = initLibrary()
local Window = Library:Load({name = "exzile", sizeX = 425, sizeY = 512, color = Color3.fromRGB(255, 255, 255)})

local Tab = Window:Tab("Aiming")
local Tab2 = Window:Tab("Visuals")

local Aimingsec1 = Tab:Section{name = "Aim Assist", column = 1}
local Visualssec1 = Tab2:Section{name = "Wallhacks", column = 1}

-- 📦 Serviços do Roblox
local Camera = workspace.CurrentCamera
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local UserInputService = game:GetService("UserInputService")
local LocalPlayer = Players.LocalPlayer

-- ⚙️ Configurações do Aimbot
local AimbotEnabled = false
local AimPart = "Head"
local Smoothing = 3
local FOVSize = 100
local FOVVisible = true
local AimbotKey = Enum.KeyCode.E -- Tecla padrão (E)
local HoldingKey = false

-- Lista de teclas e botões do mouse para ativar o Aimbot
local AvailableKeys = {
    ["E"] = Enum.KeyCode.E,
    ["Q"] = Enum.KeyCode.Q,
    ["R"] = Enum.KeyCode.R,
    ["F"] = Enum.KeyCode.F,
    ["T"] = Enum.KeyCode.T,
    ["G"] = Enum.KeyCode.G,
    ["V"] = Enum.KeyCode.V,
    ["X"] = Enum.KeyCode.X,
    ["Z"] = Enum.KeyCode.Z,
    ["C"] = Enum.KeyCode.C,
    ["Mouse1"] = Enum.UserInputType.MouseButton1, -- Botão esquerdo
    ["Mouse2"] = Enum.UserInputType.MouseButton2  -- Botão direito
}

-- Criar o círculo do FOV
local FOVCircle = Drawing.new("Circle")
FOVCircle.Color = Color3.fromRGB(255, 255, 255)
FOVCircle.Thickness = 1
FOVCircle.Transparency = 0.5
FOVCircle.NumSides = 64
FOVCircle.Filled = false
FOVCircle.Radius = FOVSize
FOVCircle.Visible = FOVVisible

local function GetClosestPlayer()
    local Target = nil
    local MaxDist = FOVSize

    for _, player in ipairs(Players:GetPlayers()) do
        if player ~= LocalPlayer and player.Character and player.Character:FindFirstChild("Humanoid") and player.Character.Humanoid.Health > 0 then
            local TargetPart = player.Character:FindFirstChild(AimPart)
            if TargetPart then
                local ScreenPos, OnScreen = Camera:WorldToScreenPoint(TargetPart.Position)
                if OnScreen then
                    local Distance = (Vector2.new(UserInputService:GetMouseLocation().X, UserInputService:GetMouseLocation().Y) - Vector2.new(ScreenPos.X, ScreenPos.Y)).Magnitude
                    if Distance < MaxDist then
                        MaxDist = Distance
                        Target = player
                    end
                end
            end
        end
    end
    return Target
end

-- Eventos para detectar quando a tecla ou botão do mouse é pressionado/solto
UserInputService.InputBegan:Connect(function(input)
    if input.KeyCode == AimbotKey or input.UserInputType == AimbotKey then
        HoldingKey = true
    end
end)

UserInputService.InputEnded:Connect(function(input)
    if input.KeyCode == AimbotKey or input.UserInputType == AimbotKey then
        HoldingKey = false
    end
end)

RunService.RenderStepped:Connect(function()
    -- Atualiza a posição e visibilidade do FOV
    FOVCircle.Position = Vector2.new(UserInputService:GetMouseLocation().X, UserInputService:GetMouseLocation().Y)
    FOVCircle.Radius = FOVSize
    FOVCircle.Visible = FOVVisible

    -- Lógica do Aimbot
    if AimbotEnabled and HoldingKey then
        local target = GetClosestPlayer()
        if target and target.Character and target.Character:FindFirstChild(AimPart) then
            local targetPos = target.Character[AimPart].Position
            Camera.CFrame = Camera.CFrame:Lerp(CFrame.new(Camera.CFrame.Position, targetPos), Smoothing / 10)
        end
    end
end)

local function GetClosestPlayer()
    local MaximumDistance = _G.CircleRadius
    local Target = nil
    for _, player in ipairs(Players:GetPlayers()) do
        if player ~= LocalPlayer and player.Character and player.Character:FindFirstChild("Humanoid") and player.Character.Humanoid.Health > 0 then
            local TargetPart = player.Character:FindFirstChild(_G.AimPart)
            if TargetPart then
                local ScreenPos, OnScreen = Camera:WorldToScreenPoint(TargetPart.Position)
                if OnScreen then
                    local Distance = (Vector2.new(UserInputService:GetMouseLocation().X, UserInputService:GetMouseLocation().Y) - Vector2.new(ScreenPos.X, ScreenPos.Y)).Magnitude
                    if Distance < MaximumDistance then
                        MaximumDistance = Distance
                        Target = player
                    end
                end
            end
        end
    end
    return Target
end

local ESPEnabled = false  -- Controle de ativação do ESP

local Players = game:GetService("Players")
local LocalPlayer = Players.LocalPlayer
local Camera = workspace.CurrentCamera
local RunService = game:GetService("RunService")

-- Tabela para armazenar as caixas de cada jogador
local ESPBoxes = {}

-- Função para desenhar o Box
local function DrawESP(player)
    if player.Character and player.Character:FindFirstChild("HumanoidRootPart") then
        local box = nil

        -- Criando o Box se o ESP estiver ativado
        if ESPEnabled then
            box = Drawing.new("Square")
            box.Color = Color3.fromRGB(255, 0, 0)  -- Cor do Box (vermelho)
            box.Thickness = 2
            box.Filled = false
            box.Visible = false
        end

        -- Armazenando a caixa do jogador na tabela
        ESPBoxes[player] = box

        -- Atualiza a posição do Box e o tamanho, se o ESP estiver ativado
        RunService.RenderStepped:Connect(function()
            if ESPEnabled and box then
                local humanoidRootPart = player.Character:FindFirstChild("HumanoidRootPart")
                if humanoidRootPart then
                    local screenPos, onScreen = Camera:WorldToScreenPoint(humanoidRootPart.Position)
                    if onScreen then
                        local head = player.Character:FindFirstChild("Head")
                        if head then
                            local headPos, onScreenHead = Camera:WorldToScreenPoint(head.Position)
                            if onScreenHead then
                                local boxSize = Vector2.new(100, math.abs(screenPos.Y - headPos.Y))
                                box.Position = Vector2.new(screenPos.X - boxSize.X / 2, headPos.Y - boxSize.Y)
                                box.Size = boxSize
                                box.Visible = true
                            end
                        end
                    else
                        box.Visible = false
                    end
                end
            else
                -- Se o ESP estiver desativado, remove o box da tela
                if box then
                    box.Visible = false
                end
            end
        end)
    end
end

-- Função para limpar os Boxes quando o ESP for desativado
local function ClearESP()
    for player, box in pairs(ESPBoxes) do
        if box then
            box.Visible = false  -- Esconde a caixa
        end
    end
    ESPBoxes = {}  -- Limpa a tabela de caixas
end

-- Função para atualizar o ESP para todos os jogadores
local function UpdateESP()
    if ESPEnabled then
        for _, player in pairs(Players:GetPlayers()) do
            if player ~= LocalPlayer then
                player.CharacterAdded:Connect(function()
                    DrawESP(player)  -- Aplica o ESP ao novo jogador que entra no jogo
                end)
                if player.Character then
                    DrawESP(player)  -- Aplica o ESP ao jogador já presente
                end
            end
        end
    else
        ClearESP()  -- Limpa os ESPs quando desativado
    end
end

-- Toggle do Aimbot
Aimingsec1:Toggle {
    Name = "Enabled",
    flag = "aimbot_toggle", 
    callback = function(bool)
        AimbotEnabled = bool
    end
}

-- Slider para suavização (Smoothing)
Aimingsec1:Slider {
    Name = "Smoothing",
    Default = 3,
    Min = 1,
    Max = 10,
    Decimals = 1,
    Flag = "aimbot_smoothing",
    callback = function(value)
        Smoothing = value
    end
}

-- Dropdown para escolher a parte do corpo a mirar
Aimingsec1:dropdown {
    name = "Aim",
    content = {"Head", "Torso", "HumanoidRootPart", "Right Arm", "Left Arm"},
    multichoice = false,
    callback = function(selection)
        AimPart = selection
    end
}

-- Toggle para mostrar/ocultar o FOV
Aimingsec1:Toggle {
    Name = "Show FOV",
    flag = "fov_toggle", 
    callback = function(bool)
        FOVVisible = bool
    end
}

-- Slider para ajustar o tamanho do FOV
Aimingsec1:Slider {
    Name = "FOV Size",
    Default = 100,
    Min = 20,
    Max = 300,
    Decimals = 1,
    Flag = "fov_size",
    callback = function(value)
        FOVSize = value
    end
}

-- Dropdown para escolher a tecla/botão de ativação do Aimbot
Aimingsec1:dropdown {
    name = "Aimbot Key",
    content = {"E", "Q", "R", "F", "T", "G", "V", "X", "Z", "C", "Mouse1", "Mouse2"},
    multichoice = false,
    callback = function(selectedKey)
        AimbotKey = AvailableKeys[selectedKey] -- Define a nova tecla ou botão do mouse
    end
}
-- Toggle para ativar/desativar o ESP
Visualssec1:Toggle {
    Name = "Enable ESP (Box)",
    flag = "esp_toggle",
    callback = function(bool)
        ESPEnabled = bool
        UpdateESP()
    end
}

-- Atualiza o ESP sempre que um jogador entra no jogo
Players.PlayerAdded:Connect(function(player)
    player.CharacterAdded:Connect(function(character)
        if ESPEnabled then
            DrawESP(player)  -- Aplica o ESP ao novo jogador
        end
    end)
end)
